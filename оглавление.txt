--------ГЛАВА 9------------------------------------------------------------------------------------------------------------------------

задача 1. 
Имеется следующий заголовочный файл:
// golf.h -- для ре9-1.срp
const int Len = 40;
struct golf
(
char fullname[Len];
int handicap; 
);
//Неинтерактивная версия :
//функция присваивает структуре типа golf имя игрока и его гандикап(фору),
//используя передаваемые ей аргументы
void setgolf (golf & g, const char* name, int hc);
//Интерактивная версия:
//функция предлагает пользователю ввести имя и гандикап,
//прис ваивает элементам структуры g в веденные значения;
//возвращает 1, если в ведено имя, и О, если введена пустая строка
int setgol f (golf & g);
//Функция устанавливает новое значение гандикапа
void handicap ( golf & g, int hc);
//Функция отобража ет содержимое структуры типа gol f
void showgo l f ( const go l f & g) ;
Обратите внимание, что функция setgo l f ( ) перегружена. Вызов первой версии функции имеет следующий вид:
gol f ann
setgo l f ( a nn , "Ann Birdfree " , 2 4 ) ;
Функция предоставляет информацию, которая содержится в структуре ann.
Вызов второй версии функции имеет следующий вид:
gol f andy
setgo l f ( andy) ;
Функция предлагает пользователю ввести имя и гандикап, а затем сохраняет эти
данные в структуре andy. Эта функция могла бы (но не обязательно) внутренне
использовать первую версию.
Постройте многофайловую программу на основе этого заголовочного файла.
Один файл по имени golf.срр должен содержать определения функций, которые соответствуют прототипам заголовочного файла.
Второй файл должен содержать функцию main() и обеспечивать реализацию всех средств прототипированных функций. Например, цикл должен запрашивать ввод массива структур
типа gol f и прекращать ввод после заполнения массива, либо когда вместо имени игрока в гольф пользователь вводит пустую строку. Чтобы получить доступ к
структурам типа golf, функция maiт() должна использовать только прототипированные функцйи.


Задача 2. 
Модифицируйте код в листинге 9.9, заменив символьный массив объектом string.
Программа больше не должна проверять, умещается ли вводимая строка, и для проверки ввода пустой строки может сравнивать вводимую строку со
значением" ".


Задача 3. 
Начните со следующего объявления структуры:
s truct cha f f
{
char dross [20] ;
int slag;
};
Напишите программу, которая использует операцию new с размещением, чтобы
поместить массив из двух таких структур в буфер. Затем программа присваивает
значения членам структуры (не забудьте воспользоваться функцией s t rcpy (}
для массива char) и отображает ее содержимое с помощью цикла. Вариант 1 
Модели памяти и пространства имен 481
предусматривает применение в качестве буфера памяти статического массива,
как было показано в листинге 9 .1 О. Вариант 2 состоит в использовании обычной
операции new для выделения памяти под буфер.


Задача 4. 
Напишите программу, включающую три файла и использующую следующее пространство имен:
namespace SALES
{
const int QUARTERS = 4;
struct Sales
douЫe sales [QUARTERS ];
douЫe average ;
douЫe max ;
douЫe mi n;
// Копирует меньшее значение из 4 или n элементов из массива
// ar в член sales структуры s, вычисляет и сохраняет
// среднее арифметическое , максимальное и минимальное
// значения введенных чисел;
// оставшиеся элементы sales , если таковые есть , устанавливаются в О
void setSales ( Sales & s, const douЫe ar [ ] , int n ) ;
// Интерактивно подсчитывает продажи за 4 квартала ,
// сохраняет их в члене sales структуры s, вычисляет и
// сохраняет среднее арифметическое , а также максималь ное
// и минимальное значения введенных чисел
void setSales ( Sales & s ) ;
// Отображает всю информацию из структуры s
void showSales ( const Sales & s ) ;
Первый файл должен быть заголовочным и содержать пространство имен.
Второй файл должен содержать исходный код и расширять пространство имен,
предоставляя определения трех прототипированных функций. В третьем файле
должны объявляться два объекта Sales. Он должен использовать интерактивную версию функции setSales ( ) для предоставления значений первой структуре и неинтерактивную версию той же функции для предоставления значений
второй структуре. Он также должен отображать содержимое обеих структур с
ПОМОЩЬЮ функции showSales (). 



-------- ГЛАВА 10-----------------------------------------------


задание 1.
Предоставьте определения методов для класса, описанного в вопросе 5,
 и напишите короткую программу для иллюстрации всех его возможностей.


задание 2.
Пусть имеется определение следующего простого класса:
class Person {
private:
static const LIMIT = 25;
string lname;  // фамилия
char fname [LIMIT]; // имя
puЫic :
Person() { lname = ""; fname [O] = ' \ О ' ; }               // #1
Person ( const string & ln, const char * fn = " Heyyou " ); // #2
// Следующие методы отображают lname и fname
void Show () con st; // формат: имя фамилия
void FormalShow () const ; // формат: фамилия , имя };
(В нем используется объект s t ring и символьный массив, так что вы сможете
сравнить применение этих двух форм.) Напишите программу, которая дополнит
реализацию за счет предоставления кода для пока еще не определенных методов.
В программе, использующей класс, должны также присутствовать вызовы
трех возможных конструкторов (без аргументов, с одним аргументом, с двумя
аргументами) и двух методов отображения. Ниже приведен пример применения
этих конструкторов и методов:
Person one;
Person two("Smythe craft ");
Person three ("Dimwiddy", "Sam");
one.Show();
cout « endl;
one.FormalShow();
// и т. д. для объектов two и three 


задание 3.
Выполните упражнение 1 из главы 9, но замените показанный там код подходящим объявлением класса gol f. Замените setgolf (golf & , const chart *, int )
конструктором с соответствующими аргументами для выполнения инициализации. Оставьте интерактивную версию setgolf ( ) , но реализуйте ее с использованием этого конструктора.
(Например, в коде setgolf () получите данные,
передайте их конструктору для создания временного объекта и присвойте временный объект вызвавшему, представленному через * this .) 


задание 4. 
Выполните упражнение 4 из главы 9, но преобразуйте структуру Sales и
ассоциированные с ней функции в класс и методы. Замените функцию
setSales ( Sales & , douЫe [ ] , int) конструктором. Реализуйте интерактивный
метод setSales ( Sales & ) , используя конструктор. Оставьте класс в пространстве имен SALES.


задание5. 
Пусть имеется следующее объявление структуры:
struct customer {
char fullname [35] ;
douЫe payment;
};
Напишите программу, которая будет добавлять структуры заказчиков в стек и
удалять их из стека, представленного объявлением класса Stack. Всякий раз,
когда заказчик удаляется из стека, его зарплата должна добавляться к промежуточной сумме и по этой сумме выдаваться отчет. На заметку: вы должны иметь
возможность пользоваться классом Stack без изменений; просто поменяйте объявление typede f, чтобы I tem был типом cus tomer вместо unsigned long.


задание 6. 
Пусть имеется следующее объявление класса:
class Move
p r ivate :
douЫe х;
douЫe у;
puЫic :
Move ( douЫe а = О, douЫe Ь = 0 ) ; 11 устанавливает х, у в а , Ь
showmove () c onst; 11 отображает текущие значения х, у
Move add (const Move & m) const;
// Эта функция добавляет х из m к х вызывающего объекта,
// чтобы получить новое значение х,
};
// Добавляет у из m к у вызывакхцего объекта , чтобы получить новое
// значение у , присваивает инициализированному объекту значения х и возвращает его
reset ( douЫe а = О, douЫe Ь = 0 ) ; / / сбрасывает х, у в а, Ь
Создайте определения функций-членов и напишите программу, которая использует этот класс


Задание 7. 
Плорг из Бетельгейзе обладает следующими свойствами:
Данные
• плорг имеет имя не длиннее 19 символов;
• плорг имеет индекс удовлетворенности (contentment index - CI) , выражаемый целым числом.
Операции
• новый плорг начинает существование с именем и индексом CI равным 50;
• индекс CI плорга может изменяться;
• плорг может сообщать свое имя и индекс CI;
• по умолчанию плорг имеет имя " Plorga " .
Напишите объявление класса Plorg (включая данные-члены и прототипы функцийчленов) , который представляет плорга. Напишите определения функций-членов.
Напишите короткую программу, демонстрирующую все средства класса Plorg.


Задание 8.
Простой список можно описать следующим образом:
• простой список может содержать ноль или более элементов определенног типа;
• можно создавать пустой список;
• можно добавлять элемент в список;
• можно определять, пуст ли список;
• можно определять, полон ли списqк.
• можно посетить каждый элемент списка и выполнить над ним определенное действие.
Как видите, список действительно прост; так, например, он не позволяет осуществлять вставку или удаление элементов.
Спроектируйте класс L i s t для представления этого абстрактного типа. Вы
должны подготовить заголовочный файл 1 i s t . h с объявлением класса и файл
list . срр с реализацией его методов. Вы должны также написать короткую программу, которая будет использовать полученный класс.
Главная причина того, что спецификация списка проста, связана с попыткой упростить это упражнение. Вы можете реализовать список в виде массива или же
в виде связного списка, если знакомы с этим типом данных. Однако открытый
интерфейс не должен зависеть от вашего выбора. То есть открытый интерфейс .
не должен иметь индексов массива, указателей на узлы и т.п. Он должен бьnъ выражен в виде общих концепций создания списка, добавления элемента в список
и т.д. Обычный способ управления посещением каждого элемента в списке и выполнения над ним каких-то действий состоит в применении функции , которая принимает указатель на другую функцию в качестве аргумента:
void visit (void ( *pf) ( I tem & ) );
Здесь pf указывает на функцию (не функцию-член ), которая принимает ссылку
на аргумент типа I tem, где I tem - это тип элементов списка. visi t () применяет
эту функцию к каждому элементу списка. В качестве общего руководства можете
воспользоваться классом S tack. 





-----------------------ГЛАВА 11--------------------------------------------

Задание 1. 
Модифицируйте код в листинге 1 1.15 так, чтобы обеспечить запись в файл
последовательных позиций при случайном блуждании. Каждая позиция должна помечаться номером шага. 
Также программа должна записывать в файл начальные условия (целевое расстояние и длину шага) и суммарные результаты.
Содержимое файла может выглядеть примерно так:
Target Distance : 100, Step Size : 20
О: (х, у) (0, 0)
1: (х, у) (-11 . 4715, 16. 383)
2: (х, у) (-8 . 688 07, - 3 . 42232 )
...
26: (х, у) = (42 . 2919, -78 . 2594 )
(х, у) = (58 . 674 9, -89 . 7309)
or 
(m, a) = (107 . 2 12, -56 . 8194)
Average outward dis tance per step = 3 . 97081


Задание 2. 
Модифицируйте заголовок класса Vector и файлы реализации (листинги 11.13
и 11.1 4) так, чтобы модуль и направление вектора больше не хранились в виде
компонентов данных. Вместо этого они должны вычисляться по требованию
при вызове методов magval ( ) и angval ( ) . Вы должны оставить открытый интерфейс без изменений (те же открытые методы с теми ж� аргументами) , но
изменить закрытую часть, включая некоторые из закрытых методов и их реализации. Протестируйте модифицированную версию с помощью программы из
листинга 11.15, которая должна остаться неизменной, поскольку открытый интерфейс класса Vector не менялся.


Задание 3. 
Модифицируйте код в листинге 11.1 5 так, чтобы вместо сообщений о результатах одиночной попытки при конкретной комбинации расстояние/шаг
 сообщагде N - целое число, вводимое пользователем.


Задание 4. 
Перепишите финальный пример класса Time (листинги 11.10, 11.11 и 1 1 .12) так,
чтобы все перегруженные операции были реализованы с использованием дружественных функций.


Задание 5.
Перепишите класс Stonewt (листинги 1 1.16 и 11.17) так, чтобы он имел член состояния, который управляет тем, в какой форме интерпретируется объект: стоуны, целочисленное значение в фунтах или значение в фунтах с плавающей точкой. Перегрузите операцию < < для замены методов show _ s tn ( ) и show _ lbs ( ) .
Перегрузите операции сложения, вычитания и умножения значений Stonewt.
Протестируйте полученный класс с помощью короткой программы, в которой
используются все методы и друзья класса.


Задание 6.
Перепишите класс Stonewt (листинги 11.16 и 11.1 7) так, чтобы перегружались
все шесть операций сравнения. Операции должны сравнивать члены pounds и
возвращать значение типа bool. Напишите программу, которая объявляет массив из шести объектов S tonewt с инициализацией в объявлении первых трех
из них. Затем программа должна в цикле читать значения, используемые для
установки остальных трех элементов массива. После этого программа должна
вывести самый маленький элемент, самый большой, а также количество элементов, которые больше или равны 11 стоунам. (Простейший подход предполагает
создание объекта S tonewt, инициализированного 11 стоунами, и сравнение с
ним других объектов.)


Задание 7. 
Комплексное число состоит из двух частей - вещественной и мнимой. Один из
способов записи такого числа выглядит как ( 3 . О, 4 . О) . Здесь 3 . О - вещественная часть, а 4. О - мнимая. Предположим, что а= (А, Bi) и с = (С, Di) . Ниже
представлены некоторые операции с комплексными числами:
• сложение: а+ с= (А + С, (В + D)i)
• вычитание: а - с = (А - С, (В - D)i)
• умножение: а*с = (Ах С - BxD, (Ax D + B x C)i)
• умножение (х - вещественное число): ххс = (х х С, xxDi)
• сопряжение: -а = (А, - Bi)
лось максимальное, минимальное и среднее количество шагов для N попыток,
Определите класс complex так, чтобы следующая программа могла использовать
его с корректными результатами:
#include <iostream>
using namespace std;
#include "complex.h " / / во избежание конфликта с complex .h
int main()
{
complex а ( 3.О ! 4.0 ); / / инициализация значением (3, 4i)
complex с;
cout << "Enter а complex numbe r (q to quit) : \ n" ;
11 Ввод комплексного числа (q для завершения )
while ( cin » с)
{
cout << "с is " << с << ' \ n ' ; / / значение с
cout << "complex conj ugate is " << -с << ' \ n ' ;
11 значение сопряженного числа
cout << "а is " << а << ' \ n ' ; 11 значение а
cout << "а + с is 11 << а + с << ' \ n'; 11 значение а + с
cout << "а - с is " << а - с << ' \ n ' ; 11 значение а - с
cout << "а * с is
cout << 1
12
•
* с is
cout << " Enter а
cout << " Done ! \ n";
return О;
11 << а * с <<
" « 2 * с <<
complex numЬe r
' \ n •; 11 значение а * с
, \n , ; 11 значение 2 * с
(q to qui t ) : \n" ;
Не забывайте, что вы должны перегрузить операции << и >>. В стандарте С++
уже присутствует поддержка комплексных чисел - и намного более развитая,
чем в этом примере - в заголовочном файле complex, поэтому во избежание
конфликтов назовите свой файл complexO . h. Используйте const там, где это
оправдано.
Ниже показан пример выполнения этой программы:
Enter а complex numЬer (q to qui t ) :
real : 10
imagina ry : 12
с is (10, 12i)
complex conj ugate is (10, -12i)
а is (3, 4i)
а + с is (13, l бi)
а - с is (-7, -Bi)
а * с is (-18, 76i)
2 * с is ( 2 0 , 2 4 i )
Enter а complex numЬer (q to qu i t):
real : q
Done !
Обратите внимание, что благодаря перегрузке, cin >> с теперь запрашивает
ввод вещественной и мнимой частей комплексного числа. 